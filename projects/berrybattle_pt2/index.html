<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <script async src="https://www.googletagmanager.com/gtag/js?id=G-01NSK99TZ0"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-01NSK99TZ0");</script> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Berry Battle Pt.2 | Aven Arlington</title> <meta name="author" content="Aven Arlington"> <meta name="description" content="gRPC Prototype and Performance Benchmarks"> <meta name="keywords" content="Rust programming language, Rust tutorials, Rust graphics programming, Rust utilities, Rust projects, Rust examples, Rust game development tutorials, Rust embedded systems programming guide, Graphics programming using Rust language, Embedded development with Rust, IoT programming in Rust, Video game design in Rust, IoT projects with Rust programming, Circuit design, portfolio-website, tutorial, "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://aven-arlington.github.io/projects/berrybattle_pt2/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Aven </span>Arlington</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">GitHub Repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Resume</a> </li> <li class="nav-item "> <a class="nav-link" href="/cookoffs/">Cook-off</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Berry Battle Pt.2</h1> <p class="post-description">gRPC Prototype and Performance Benchmarks</p></header> <article> <h2 id="topics-covered">Topics Covered</h2> <ul> <li>Using gRPC with Rust</li> <li>Cargo Build Scripts</li> <li>Tests</li> <li>Performance benchmarking</li> </ul> <h2 id="tldr">TLDR</h2> <p><a href="https://github.com/berrybattle/berry-battle-server/tree/v0.0.2" rel="external nofollow noopener" target="_blank">Game Simulator Source…</a></p> <p><a href="https://github.com/berrybattle/berry-battler/tree/v0.0.2" rel="external nofollow noopener" target="_blank">AI Node Source…</a></p> <h2 id="background">Background</h2> <p>Following the conception of the project the first problem I need to solve is communication between the server and AI nodes. I don’t think something with direct access is viable since few people would open their hardware up to the world for direct ssh connections. So I need a higher level web API that is proven to be safe, language agnostic, performant, and preferably modern. I looked at REST, and HTTP with JSON before settling on gRPC which appears to meet my criteria.</p> <p>The next step is figuring out how it can be implemented with Rust in a way that will work with my high level goals. Once I get basic communications running I will run some simple performance benchmarks to confirm the approach is feasible.</p> <h2 id="lets-tackle-the-problem">Let’s Tackle the Problem</h2> <h3 id="defining-the-protocol-buffer">Defining the Protocol Buffer</h3> <p>I found several helpful examples for using gRPC with Rust and the general consensus seemed to be that the tonic crate was the way to go. The <a href="https://github.com/hyperium/tonic/tree/master/examples" rel="external nofollow noopener" target="_blank">tonic repository has quite a few working examples</a> that really helped me get started. I won’t go into tons of detail about gRPC specifically but will cover my journey from the tonic examples to my working prototype.</p> <p>The first thing I wanted to do was establish some general data structures. To help protect against hacking or cheating I want the bytes coming in and out to be well defined and certainly not a binary blob. Tonic/gRPC handles this with protocol buffers that are defined in files with the <code class="language-plaintext highlighter-rouge">.proto</code> extension. My definitions can be spread logically across multiple files and then they are combined and compiled together in a pre-build process or what cargo calls a build script. Note that the build script doesn’t actually do the compiling, instead it initiates a build with <code class="language-plaintext highlighter-rouge">protoc</code> which then compiles the protocol buffer into a intermediary <code class="language-plaintext highlighter-rouge">*.rs</code> file.</p> <p>The project setup looks something like this:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">package-root
  ├── proto
  │     ├── data.rs
  │     └── services.rs
  ├── src
  │     ├── lib.rs
  │     └── main.rs
  ├── Cargo.toml
  └── build.rs

</span></code></pre></div></div> <p>The build script had to be modified from the example so that it builds all my <code class="language-plaintext highlighter-rouge">.proto</code> files. In it we can see that the build script defines the output directory to place the code-generated <code class="language-plaintext highlighter-rouge">*.rs</code> files before compiling the protocol definition files with <code class="language-plaintext highlighter-rouge">tonic_build</code>. I also prefix the <code class="language-plaintext highlighter-rouge">file_descriptor_set_path</code> with “bb_rpc_” which is the name of protocol definition package that I define shortly.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// build.rs</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">env</span><span class="p">,</span> <span class="nn">path</span><span class="p">::</span><span class="n">PathBuf</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">out_dir</span> <span class="o">=</span> <span class="nn">PathBuf</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="nn">env</span><span class="p">::</span><span class="nf">var</span><span class="p">(</span><span class="s">"OUT_DIR"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="nn">tonic_build</span><span class="p">::</span><span class="nf">configure</span><span class="p">()</span>
        <span class="nf">.build_client</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="nf">.file_descriptor_set_path</span><span class="p">(</span><span class="n">out_dir</span><span class="nf">.join</span><span class="p">(</span><span class="s">"bb_rpc_descriptor.bin"</span><span class="p">))</span>
        <span class="nf">.compile</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="p">[</span><span class="s">"proto/data.proto"</span><span class="p">,</span> <span class="s">"proto/services.proto"</span><span class="p">],</span>
            <span class="o">&amp;</span><span class="p">[</span><span class="s">"proto"</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now I was able to start experimenting with my data structures. I split the protocol buffer definition into two files based on their purpose. One file would contain the data model and the other would contain the communication services.</p> <p>For this prototype and benchmarking experiment I need the data to be representative of a simple but typical game object. It needed to define things like position, direction, enumerations for state, strings, and representations of time. It also needed to represent lists of data like a vector or an array. I ended up using the following as a starting point…</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">// data.proto
</span><span class="gp">syntax = "proto3";</span><span class="w">
</span><span class="gp">package bb_grpc;</span><span class="w">
</span><span class="go">enum UpdateStatus {
</span><span class="gp">      PROCESSING = 0;</span><span class="w">
</span><span class="gp">      FINISHED = 1;</span><span class="w">
</span><span class="go">}
enum UnitType {
</span><span class="gp">      UNKNOWN = 0;</span><span class="w">
</span><span class="gp">      MOBILE = 1;</span><span class="w">
</span><span class="gp">      STATIC = 2;</span><span class="w">
</span><span class="go">}
message UnitDirectionVector {
</span><span class="gp">      float x = 1;</span><span class="w">
</span><span class="gp">      float y = 2;</span><span class="w">
</span><span class="go">}
message UnitPosition {
</span><span class="gp">      float x = 1;</span><span class="w">
</span><span class="gp">      float y = 2;</span><span class="w">
</span><span class="gp">      uint32 layer = 3;</span><span class="w">
</span><span class="gp">      UnitDirectionVector direction = 4;</span><span class="w">
</span><span class="go">}
message UnitState {
</span><span class="gp">      uint32 id = 1;</span><span class="w">
</span><span class="gp">      UnitType unit_type = 2;</span><span class="w">
</span><span class="gp">      UnitPosition position = 3;</span><span class="w">
</span><span class="gp">      string tag = 4;</span><span class="w">
</span><span class="go">}
message UpdateRpcRequest {
</span><span class="gp">      UpdateStatus status = 1;</span><span class="w">
</span><span class="gp">      uint32 update_id = 2;</span><span class="w">
</span><span class="gp">      repeated UnitState units = 3;</span><span class="w">
</span><span class="gp">      uint64 per_unit_proc_time_ns = 4;</span><span class="w">
</span><span class="go">}
message UpdateRpcResponse {
</span><span class="gp">      UpdateStatus updated_status = 1;</span><span class="w">
</span><span class="gp">      uint32 update_id = 2;</span><span class="w">
</span><span class="gp">      repeated UnitState units = 3;</span><span class="w">
</span><span class="gp">      uint64 per_unit_proc_time_ns = 4;</span><span class="w">
</span><span class="gp">      uint64 single_pass_elapsed_time_us = 5;</span><span class="w">
</span><span class="go">}
</span></code></pre></div></div> <p>The protocol buffer definition files are compiled into rust files with syntax you would expect. The <code class="language-plaintext highlighter-rouge">package</code> field acts as a crate name when referenced in the <code class="language-plaintext highlighter-rouge">*.rs</code> files. The <code class="language-plaintext highlighter-rouge">message</code> prefix will compile the item into a <code class="language-plaintext highlighter-rouge">struct</code> object which I use to interact with in the application. Lists of objects are created with the <code class="language-plaintext highlighter-rouge">repeated</code> prefix as shown in both <code class="language-plaintext highlighter-rouge">UpdateRpcRequest</code> and <code class="language-plaintext highlighter-rouge">UpdateRpcResponse</code>. Nesting is also intuitive as can be seen with the <code class="language-plaintext highlighter-rouge">UnitDirectionVector</code> nested within the <code class="language-plaintext highlighter-rouge">UnitPosition</code> which itself is nested in a <code class="language-plaintext highlighter-rouge">UnitState</code> object.</p> <p>The servers and services are also easy to define. In this case I am using a single <code class="language-plaintext highlighter-rouge">UpdateService</code> service which tells the gRPC server to listen for a <code class="language-plaintext highlighter-rouge">UpdateRpc</code> event and reply with a <code class="language-plaintext highlighter-rouge">UpdateRpcResponse</code> which we will define in a handler.</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">// services.proto
</span><span class="gp">syntax = "proto3";</span><span class="w">
</span><span class="gp">package bb_grpc;</span><span class="w">
</span><span class="gp">import "data.proto";</span><span class="w">
</span><span class="go">service UpdateService {
</span><span class="gp">  rpc UpdateRpc (UpdateRpcRequest) returns (UpdateRpcResponse);</span><span class="w">
</span><span class="go">}
</span></code></pre></div></div> <h3 id="handling-the-update-event-simulator---grpc-client">Handling the Update Event (Simulator - gRPC Client)</h3> <p>Both the simulator (gRPC client) and the AI node (gRPC server) share the same buffer protocol definition, build scripts, and general setup mentioned above. They differ in how they use the generated code since the simulator is requesting a service and the AI node is actually running the gRPC server.</p> <p>The gRPC client code is relatively simple. I create a <code class="language-plaintext highlighter-rouge">async</code> function to perform the RPC and provide it with a <code class="language-plaintext highlighter-rouge">UpdateRpcRequest</code> as we defined in our <code class="language-plaintext highlighter-rouge">.proto</code> file. The client then tries to connect with the gRPC server and waits for a connection to be established. Once successful, the <code class="language-plaintext highlighter-rouge">UpdateRpc</code> event is triggered with our supplied data, <code class="language-plaintext highlighter-rouge">current_state</code> of type <code class="language-plaintext highlighter-rouge">UpdateRpcRequest</code>. When the <code class="language-plaintext highlighter-rouge">UpdateRpc</code> call is complete, either a <code class="language-plaintext highlighter-rouge">UpdateRpcResponse</code> object or an Error is returned.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// berry-battle-server/src/main.rs</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">request_updates</span><span class="p">(</span>
    <span class="n">current_state</span><span class="p">:</span> <span class="n">UpdateRpcRequest</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">UpdateRpcResponse</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">client</span> <span class="o">=</span> <span class="nn">UpdateServiceClient</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="s">"http://[::1]:50051"</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="k">match</span> <span class="n">client</span><span class="nf">.update_rpc</span><span class="p">(</span><span class="n">current_state</span><span class="p">)</span><span class="k">.await</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">response</span><span class="nf">.into_inner</span><span class="p">()),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">e</span><span class="p">)),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Packaging the data into the <code class="language-plaintext highlighter-rouge">UpdateRpcRequest</code> object just like instantiating any other struct in Rust and I will cover it a little later. That’s it for the client gRPC side.</p> <h3 id="handling-the-update-event-ai-node---grpc-server">Handling the Update Event (AI Node - gRPC Server)</h3> <p>The gRPC server takes a little more to setup but not much. We need to define a <code class="language-plaintext highlighter-rouge">struct</code> so that we can access our custom trait implementations like they were virtual functions. In this case I named it <code class="language-plaintext highlighter-rouge">UpdateServiceTraitWrapper</code>. The <code class="language-plaintext highlighter-rouge">UpdateService</code> defined with the <code class="language-plaintext highlighter-rouge">service</code> keyword in the <code class="language-plaintext highlighter-rouge">.proto</code> file determines the name of the virtual function, or trait, that I need to make an implementation for. This trait implementing struct can be named whatever you want as long as the implementation defined below it matches the service name in the <code class="language-plaintext highlighter-rouge">*.proto</code> file. The implementation of <code class="language-plaintext highlighter-rouge">UpdateService</code> holds the data handling/processing code. For code modularity I split those details into a <code class="language-plaintext highlighter-rouge">simulate_game_update</code> function which returns the processed <code class="language-plaintext highlighter-rouge">UpdateRpcResponse</code> which is then returned to the calling client through gRPC.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// berry-battler/src/main.rs</span>
<span class="nd">#[derive(Default)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">UpdateServiceTraitWrapper</span> <span class="p">{}</span>

<span class="nd">#[tonic::async_trait]</span>
<span class="k">impl</span> <span class="n">UpdateService</span> <span class="k">for</span> <span class="n">UpdateServiceTraitWrapper</span> <span class="p">{</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">update_rpc</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="k">mut</span> <span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="o">&lt;</span><span class="n">UpdateRpcRequest</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Response</span><span class="o">&lt;</span><span class="n">UpdateRpcResponse</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Status</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Got a request from {:?}"</span><span class="p">,</span> <span class="n">request</span><span class="nf">.remote_addr</span><span class="p">());</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="nn">Response</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">simulate_game_update</span><span class="p">(</span><span class="n">request</span><span class="nf">.get_mut</span><span class="p">())))</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We then have to start the server itself in <code class="language-plaintext highlighter-rouge">main</code>. We let the variable <code class="language-plaintext highlighter-rouge">update_rpc</code> contain the default event for the <code class="language-plaintext highlighter-rouge">UpdateServiceTraitWrapper</code> which is simply our implementation of the <code class="language-plaintext highlighter-rouge">UpdateService</code> trait. I then pass that implementation to a server builder which creates the <code class="language-plaintext highlighter-rouge">UpdateServiceServer</code>, starts it, and leaves it listening for client gRPC calls.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">addr</span> <span class="o">=</span> <span class="s">"[::1]:50051"</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"Server listening on {}"</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">update_rpc</span> <span class="o">=</span> <span class="nn">UpdateServiceTraitWrapper</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="nn">Server</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
        <span class="nf">.add_service</span><span class="p">(</span><span class="nn">UpdateServiceServer</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">update_rpc</span><span class="p">))</span>
        <span class="nf">.serve</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
        <span class="k">.await</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="data-handling">Data Handling</h3> <p>Preparing the data for transmission and interpreting the response is handled just like any normal Rust application. In this case the game simulation server (confusingly the gRPC client) prepares some simulated game data of different sizes and sends it to the AI node (the gRPC server). I will only show a portion of the source that demonstrates how the messages in the protocol definition translate into Rust <code class="language-plaintext highlighter-rouge">structs</code> that can be interacted with in the usual ways. Note that I moved these functions into tests since they are benchmarks and won’t be part of the main application. The <code class="language-plaintext highlighter-rouge">request_update</code> function is in the main code body.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// berry-battle-server/src/main.rs</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">generate_sample_units</span><span class="p">(</span><span class="n">count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">UnitState</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">thread_rng</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">sample_unit</span> <span class="o">=</span> <span class="n">UnitState</span> <span class="p">{</span>
            <span class="n">id</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">(),</span>
            <span class="n">unit_type</span><span class="p">:</span> <span class="nn">UnitType</span><span class="p">::</span><span class="n">Mobile</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">,</span>
            <span class="n">position</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">UnitPosition</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">(),</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">(),</span>
                <span class="n">layer</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">(),</span>
                <span class="n">direction</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">UnitDirectionVector</span> <span class="p">{</span>
                    <span class="n">x</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">(),</span>
                    <span class="n">y</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">(),</span>
                <span class="p">}),</span>
            <span class="p">}),</span>
            <span class="n">tag</span><span class="p">:</span> <span class="s">"Sample"</span><span class="nf">.into</span><span class="p">(),</span>
        <span class="p">};</span>
        <span class="nd">vec!</span><span class="p">[</span><span class="n">sample_unit</span><span class="nf">.clone</span><span class="p">();</span> <span class="n">count</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">generate_update_state_request</span><span class="p">(</span>
        <span class="n">unit_count</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">processing_time_ns</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">UpdateRpcRequest</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">thread_rng</span><span class="p">();</span>
        <span class="n">UpdateRpcRequest</span> <span class="p">{</span>
            <span class="n">status</span><span class="p">:</span> <span class="nn">UpdateStatus</span><span class="p">::</span><span class="n">Processing</span> <span class="k">as</span> <span class="nb">i32</span><span class="p">,</span>
            <span class="n">update_id</span><span class="p">:</span> <span class="n">rng</span><span class="py">.gen</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span><span class="p">(),</span>
            <span class="n">units</span><span class="p">:</span> <span class="nf">generate_sample_units</span><span class="p">(</span><span class="n">unit_count</span><span class="p">),</span>
            <span class="n">per_unit_proc_time_ns</span><span class="p">:</span> <span class="n">processing_time_ns</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div> <p>The AI node processes each “unit” like it would in a real game by modifying all the fields to random values and packaging them in a struct. I also have some timers in place to measure the elapsed time for data processing with some build in overhead, represented by a sleep timer, to simulate a more robust processing loop. This performance information is added to the the response data so it can be logged by the game simulation server. It is very similar to the code above and not much value to the discussion on gRPC.</p> <p>I will note that in order to write tests that call <code class="language-plaintext highlighter-rouge">async</code> functions like <code class="language-plaintext highlighter-rouge">request_update</code> they will need to be adorned with the <code class="language-plaintext highlighter-rouge">#[tokio::test(flavor = "multi_thread")]</code> attribute.</p> <h2 id="summary">Summary</h2> <p>Only portions of the code relating specifically to gRPC were detailed here but the entire project can be cloned, built, and executed for experimentation. <a href="https://github.com/berrybattle/berry-battler/tree/v0.0.2" rel="external nofollow noopener" target="_blank">The AI Node</a> <a href="https://github.com/berrybattle/berry-battle-server/tree/v0.0.2" rel="external nofollow noopener" target="_blank">The Simulation Server</a></p> <p>By default, the source is configured to have both the AI node and the simulation server running on the same machine with a localhost connection. To run the code on separate machines, change “[::1]” to an IP address or host name.</p> <p>The AI node should be started first with <code class="language-plaintext highlighter-rouge">cargo run</code> in either <code class="language-plaintext highlighter-rouge">release</code> or <code class="language-plaintext highlighter-rouge">debug</code> configurations.</p> <p>Running the tests on the server can be done with <code class="language-plaintext highlighter-rouge">cargo test --release -- --nocapture</code> since the benchmarking code is wrapped in a test.</p> <p>The output should look like this:</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">Connecting to gRPC server
To simulate unit processing e.g. running A* etc on each unit
Apply constant processing time of 100000ns per unit

 Unit Count | Processing Time (us) | Latency (us) |
          0 |                    0 |         4303 |
         10 |                 1064 |         6020 |
         20 |                 2062 |         5174 |
         30 |                 3064 |         7636 |
         40 |                 4065 |         7991 |
         50 |                 5067 |         9615 |
         60 |                 6070 |        10414 |
         70 |                 7070 |        11162 |
         80 |                 8073 |        12808 |
         90 |                 9076 |        13594 |
        100 |                10076 |        14536 |
        110 |                11078 |        14693 |
        120 |                12076 |        15957 |
        130 |                13081 |        17615 |
        140 |                14080 |        18390 |
        150 |                15082 |        19572 |
        160 |                16084 |        20517 |
        170 |                17108 |        21769 |
        180 |                18091 |        22967 |
        190 |                19090 |        23434 |
        200 |                20091 |        24743 |
test tests::test_node_performance ... ok

</span><span class="gp">test result: ok. 1 passed;</span><span class="w"> </span>0 failed<span class="p">;</span> 0 ignored<span class="p">;</span> 0 measured<span class="p">;</span> 0 filtered out<span class="p">;</span> finished <span class="k">in </span>0.66s
</code></pre></div></div> <h2 id="additional-resources">Additional Resources</h2> <ul> <li><a href="https://learn.microsoft.com/en-us/aspnet/core/grpc/comparison?view=aspnetcore-8.0" rel="external nofollow noopener" target="_blank">Compare gRPC services with HTTP APIs</a></li> <li><a href="https://grpc.io/" rel="external nofollow noopener" target="_blank">gRPC</a></li> <li><a href="https://grpc.io/docs/what-is-grpc/introduction/" rel="external nofollow noopener" target="_blank">Introduction to gRPC</a></li> <li><a href="https://docs.rs/tonic/latest/tonic/" rel="external nofollow noopener" target="_blank">Crate tonic</a></li> <li><a href="https://github.com/hyperium/tonic" rel="external nofollow noopener" target="_blank">GitHub hyperium/tonic</a></li> </ul> </article> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Aven Arlington. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with a heavily modified <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Last updated: February 03, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?07b8786bab9b4abe90d10e61f7d12ff7" type="text/javascript"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>